# Writing Jupyter Kernels on the JVM

[quote, 'link:https://jupyter.org/[Jupyter]']
Project Jupyter exists to develop open-source software, open-standards, and services for interactive computing across dozens of programming languages.

Jupyter is much more than software. It is also a set of standards and specifications that tools can build against to communicate. One such example is at the core of the project, kernels.

A Jupyter kernel has the role of providing an execution backend for a language. A frontend that "speaks" Jupyter can connect to a kernel and ask it to run code, provide code completion suggestions, documentation, and more.

The entire kernel communication protocol is outlined in the link:http://jupyter-client.readthedocs.io/en/latest/messaging.html[Messaging in Jupyter docs]. Implementing the entire protocol is quite the undertaking and unnecessary for every kernel to redo themselves. See link:https://jupyter-client.readthedocs.io/en/stable/wrapperkernels.html[Making simple Python wrapper kernels] for example. The link:{project_jupyter-jvm-basekernel_root}/README.md[Jupyter JVM Basekernel] is intended to provide a similar API with an implementation in pure Java.

## Packaging, project structure, and dependencies

Good news, packaging is all wrapped up in a Gradle plugin! For that reason this tutorial will focus on setting up a Gradle project including configuring the Jupyter installation plugin. That plugin is open source on GitHub, it's called the link:https://github.com/SpencerPark/Jupyter-kernel-installer-gradle[jupyter-kernel-installer].

Quick refresher/introduction to Gradle time. The link:https://gradle.org/[Gradle] docs are a great resource, and really well written/maintained so we'll skip over the install details. Gradle is a build tool, and a very popular one for languages on the JVM. You'll only need gradle to install the wrapper, after which, all Gradle interaction will happen through the `gradlew` wrapper binary.

A good place to start is the link:{project_example_root}[example kernel]. Cloning that project will let you _skip the manual Gradle install_ as the `gradlew`, `gradlew.bat`, and `gradle/wrapper/` are committed under revision control. This may go against what you were taught about version control conventions, but I'm not here to argue about it. I like to commit it simply because it makes it much easier to clone and build so it's worth breaking the VCS rules.

[source,shell,subs="attributes+"]
....
git clone {git_url}
cd example
gradlew build # <1>
....
<1> Install the Gradle version specified in the build script's `wrapper` closure and builds the project.

### Project structure

The example project has a folder structure like the following. It is a fairly standard layout for a Gradle built project.

....
project_root
 │   build.gradle <1>
 │   gradlew
 │   gradlew.bat
 │   settings.gradle
 ├───gradle
 │   └───wrapper
 │           gradle-wrapper.jar
 │           gradle-wrapper.properties
 ├───kernel <2>
 │       logo-32x32.png <3>
 │       logo-64x64.png
 └───src
     └───main
         └───java
             └───... <4>
....
<1> Kernel configuration, dependencies, and any other compiler/build related things.
<2> All resources copied directly into the installation directory of the kernel.
<3> The `logo-32x32.png` and `logo-64x64.png` are special named files. Jupyter may use that as the icon for your kernel.
<4> Kernel source code goes in here.

The cloned `build.gradle` is not much different from that of a plain java library. Where it differs is with the addition of the jupyter plugin and configurations closures that come with it.

.Build scripts
****
.build.gradle
[source, gradle]
....
include::{example_root}/build.gradle[]
....
<1> Include the jupyter plugin. It is published on the gradle plugin portal.
<2> The group name of the project's maven coordinates. Should be a unqiue reverse domain you control. As such, your reverse github pages url is a fairly good choice.
<3> The kernel needs the base kernel and it's dependencies at runtime so we `shade` (include) it in the built jar.
<4> Make sure the jar is runnable by providing the fully qualified name of the main class. The contents of that class will be discussed later.
<5> The jupyter block configures the various properties of the kernel. It is primarily driven by the contents of the `kernel.json` (a jupyter kernel manifest file) that is generated by the plugin. Will also be discussed further later.
<6> The `zipKernel` closure likely doesn't need any changing as the python installer is a great choice. All jupyter installations need python so it will be available on the installer's system.

.settings.gradle
[source, gradle]
....
include::{example_root}/settings.gradle[]
....
<1> The artifact name. Feel free to pick whatever you like!
****

### The `kernel.json`

This file is the manifest for the kernel. It is specially named and belongs in a directory with the name of the kernel, somewhere on the jupyter path. It is refered to as the "kernel spec". See the link:https://jupyter-client.readthedocs.io/en/stable/kernels.html#kernel-specs[Kernel specs] documentation for more information.

**This file is automatically generated from the `jupyter` closure specifications.** The full details of the contents of that configuration can be found in the link:https://github.com/SpencerPark/Jupyter-kernel-installer-gradle[Jupyter kernel installer gradle plugin docs]. Here is the quick summary:

.build.gradle
[source, gradle]
----
jupyter {
    kernelName = 'nashorn-js' // <1>
    kernelDisplayName = 'NashornJS' // <2>
    kernelLanguage = 'js' // <3>
    kernelInterruptMode = 'message' // <4>
    kernelParameters { // <5>
        list('engine-arg', 'JS_ENGINE_ARGS') {
            separator = ' '
            description = 'A comma separated list of arguments to give to the scripting engine.'
        }
    }
}
----
<1> The kernel name. This name is referred to in jupyter commands and is the name of the install directory. It must be restricted to ascii letters, numbers, and `-`, `.`, and `_`. Feel free to use the language name here.
<2> The display name is what appears in UI and where a clever, presentable, name would go. A combination of the project name and language, if the project doesn't imply it already, works well here.
<3> The language that the kernel executes. This fallback is used to find a kernel if (for example) a notebook specifies a kernel that can't be found, but another kernel that executes the same language can be.
<4> On the JVM the interrupt mode `'message'` is likely what you want. A `'signal'` is the other option but handling one is not as easy as a message. This affects how interrupts are requested.
<5> Kernel parameters are a partially made up construct implemented on top of the `"env"` object from the kernel spec. They are simple flags that the end user running an install script can provide. They are then put into the `"env"` object and therefore become environment variables when the kernel is started. Use `System.getenv(String)` to retrieve them.

The `kernel.json` for the above looks like the following:

.kernel.json
[source, json]
----
{
    "argv": [ // <1>
        "java",
        "-jar",
        "@KERNEL_INSTALL_DIRECTORY@/example-1.0.0-SNAPSHOT.jar",
        "{connection_file}"
    ],
    "display_name": "NashornJS",
    "language": "js",
    "interrupt_mode": "message",
    "env": {
        // <2>
    }
}
----
<1> This command is run by Jupyter to start the kernel. It runs the jar with a single argument, the `{connection_file}`. This is why we need to specify the main class and take a single command line argument.
<2> If the installation sets any variables, this is where they end up.

### Main class

